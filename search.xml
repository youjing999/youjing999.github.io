<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>浅析数据结构</title>
    <url>/2019/11/24/%E6%B5%85%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h2 id="浅析数据结构"><a href="#浅析数据结构" class="headerlink" title="浅析数据结构"></a>浅析数据结构</h2><p>虽然我是一个菜鸟，但还是想把学到的东西和大家一起分享，有错误以及不足还请指正。</p>
<p>数据结构的知识总结于严奶奶的经典书籍、天勤、王道…</p>
<p>还有一些大佬的理解和自己的理解。</p>
<p>希望和大家一起学习，一起进步！</p>
<a id="more"></a>

<hr>
<h3 id="数据结构和算法概述"><a href="#数据结构和算法概述" class="headerlink" title="数据结构和算法概述"></a>数据结构和算法概述</h3><h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h3><p>​    <strong>1.指针</strong></p>
<p>​    <strong>2.结构体</strong></p>
<p>​    <strong>3.动态内存分配和释放</strong></p>
<h3 id="模块一："><a href="#模块一：" class="headerlink" title="模块一："></a>模块一：</h3><p>​    <strong>1.线性结构</strong></p>
<p>​    <strong>2.连续存储[数组]</strong></p>
<p>​    <strong>3.离散存储[链表]</strong></p>
<ul>
<li><strong>a.单链表</strong>  </li>
<li><strong>b.循环单链表</strong></li>
<li><strong>c.双链表&amp;循环双链表</strong>  </li>
</ul>
<p><strong>4.线性结构的两种常见应用</strong></p>
<ul>
<li><strong>a.栈</strong></li>
<li><strong>b.队列</strong></li>
</ul>
<p>​    </p>
<h3 id="模块二：-串"><a href="#模块二：-串" class="headerlink" title="模块二： 串"></a>模块二： 串</h3><p>​     <strong>1、串的定义以及实现</strong></p>
<p>​     <strong>2、串的模式匹配算法</strong></p>
<h3 id="模块三：数组"><a href="#模块三：数组" class="headerlink" title="模块三：数组"></a>模块三：数组</h3><p>​    <strong>1、数据的定义以及实现</strong></p>
<p>​    <strong>2、矩阵的压缩矩阵</strong></p>
<h3 id="专题：递归"><a href="#专题：递归" class="headerlink" title="专题：递归"></a>专题：递归</h3><p>​    <strong>1、1 + 2 + 3 +…+ 100的和</strong></p>
<p>​    <strong>2、求阶乘</strong></p>
<p>​    <strong>3、汉诺塔</strong></p>
<h3 id="模块四：非线性结构"><a href="#模块四：非线性结构" class="headerlink" title="模块四：非线性结构"></a>模块四：非线性结构</h3><p>​    <strong>1、树</strong></p>
<p>​    <strong>2、图</strong></p>
<h3 id="模块五：查找和排序"><a href="#模块五：查找和排序" class="headerlink" title="模块五：查找和排序"></a>模块五：查找和排序</h3><ul>
<li><strong>查找：</strong></li>
</ul>
<p>​        <strong>1. 静态查找表</strong></p>
<p>​        <strong>2、动态查找表</strong></p>
<p>​        <strong>2、 哈希表</strong></p>
<ul>
<li><strong>排序：</strong></li>
</ul>
<p>​        <strong>1、内部排序</strong></p>
<p>​        <strong>2、外部排序</strong> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"About Beautiful Thing"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>01_浅析数据之绪论</title>
    <url>/2019/11/29/01-%E6%B5%85%E6%9E%90%E6%95%B0%E6%8D%AE%E4%B9%8B%E7%BB%AA%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="浅析数据结构之绪论"><a href="#浅析数据结构之绪论" class="headerlink" title="浅析数据结构之绪论"></a>浅析数据结构之绪论</h1><a id="more"></a>

<h2 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a><strong>数据结构和算法</strong></h2><ul>
<li><strong>数据：</strong> 是客观事物的符号表示。在计算机科学中指的是所有能输入到计算机中并被计算机程序处理的符号的总称。</li>
<li><strong>数据元素：</strong>组成数据的，有一定意义的基本单位，在计算机中通常作为整体进行考虑和处理，也被称为记录。</li>
<li><strong>数据元素组成数据。</strong></li>
<li><strong>数据项：</strong>数据项是数据不可分割的最小单元，一个数据元素可以由若干个数据项组成。数据项是对客观事物某一方面特性的数据描述。</li>
<li><strong>数据对象：</strong>性质相同的数据元素的集合，是数据的子集</li>
</ul>
<hr>
<h2 id="数据结构概述"><a href="#数据结构概述" class="headerlink" title="数据结构概述"></a><strong>数据结构概述</strong></h2><p><strong>数据结构(Data Structure)：</strong>是指相互之间具有(存在)一定联系(关系)的数据元素的集合。元素之间的相互联系(关系)称为逻辑结构。数据元素之间的逻辑结构有<u>四种基本逻辑类型</u>：<br><strong>逻辑结构：</strong></p>
<ul>
<li><strong>1、集合结构：</strong><br>1.集合结构中数据元素同属于一个集合。<br>2.数据元素相互之间没有关系。</li>
<li><strong>2、线性结构：</strong> 数据元素之间是一对一的关系。</li>
<li><strong>3、树形结构：</strong> 数据元素之间一种一对多的层次关系。</li>
<li><strong>4、图状结构（网状结构）：</strong> 数据元素之间是多对多的关系。</li>
</ul>
<p><strong>物理结构：</strong>又叫存储结构，是指数据的逻辑结构在计算机中的存储形式。</p>
<ul>
<li><strong>1、线性：</strong>数据元素的存储<br>数组、链表<br>具体应用：栈和队列（特殊的线性结构）</li>
<li><strong>2、非线性：</strong>元素之间的关系的表示<br>  树、图</li>
</ul>
<p>元素之间的关系在计算机中有两种不同的表示方法：顺序表示和非顺序表示。由此得出两种不同的存储结构：<u>顺序存储结构</u>和<u>链式存储结构</u>。</p>
<ul>
<li><p><strong>顺序存储结构：</strong>用数据元素在存储器中的相对位置来表示数据元素之间的逻辑结构(关系)。</p>
</li>
<li><p><strong>链式存储结构：</strong>在每一个数据元素中增加一个存放另一个元素地址的指针(pointer )，用该指针来表示数据元素之间的逻辑结构(关系)。</p>
<p>数据的逻辑结构和物理结构是密不可分的两个方面，一个<em>算法的设计取决于所选定的逻辑结构</em>，而<em>算法的实现依赖于所采用的存储结构</em>。</p>
</li>
</ul>
<p>在C语言中，用一维数组表示顺序存储结构；用结构体类型表示链式存储结构</p>
<h3 id="数据结构的三个组成部分："><a href="#数据结构的三个组成部分：" class="headerlink" title="数据结构的三个组成部分："></a>数据结构的三个组成部分：</h3><ul>
<li><strong>逻辑结构：</strong> 数据元素之间逻辑关系的描述<br>D_S=（D，S）</li>
<li><strong>存储结构：</strong> 数据元素在计算机中的存储及其逻辑关系的表现称为数据的存储结构或物理结构。</li>
<li><strong>数据操作：</strong> 对数据要进行的运算。</li>
</ul>
<hr>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a><strong>算法</strong></h2><h3 id="算法的五大特性："><a href="#算法的五大特性：" class="headerlink" title="算法的五大特性："></a>算法的五大特性：</h3><ul>
<li>有穷性：有穷步 有穷时间</li>
<li>确定性：每一条指令都有明确的含义</li>
<li>可行性：算法描述的操作都是可以通过已经实现的基本运算执行有限次来实现</li>
<li>输入: 一个算法有零个或多个输入，这些输入取自于某个特定的对象集合</li>
<li>输出: 一个算法有一个或多个输出，这些输出是同输入有着某些特定关系的量</li>
</ul>
<h3 id="算法的设计要求"><a href="#算法的设计要求" class="headerlink" title="算法的设计要求"></a>算法的设计要求</h3><ul>
<li>正确性：算法应当满足具体问题的需求</li>
<li>可读性：算法主要是为了人的阅读与交流，其次才是机器执行</li>
<li>健壮性：输入的数据非法时，算法应当作出反应或者进行</li>
<li>通用性： 算法应具有一般性 ，即算法的处理结果对于一般的数据集合都成立。相应的处理，而不是产生莫名其妙的输出结果</li>
<li>高效率与低存储量需求： 效率指的是算法执行的时间；存储量需求指算法执行过程中所需要的最大存储空间。一般地，这两者与问题的规模有关</li>
</ul>
<h3 id="算法效率的质量"><a href="#算法效率的质量" class="headerlink" title="算法效率的质量"></a>算法效率的质量</h3><p>  算法执行时间需通过依据该算法编制的程序在计算机上运行所消耗的时间来度量。其方法通常有两种：</p>
<ul>
<li><strong>事后统计：</strong>计算机内部进行执行时间和实际占用空间的统计。<br>问题：必须先运行依据算法编制的程序；依赖软硬件环境，容易掩盖算法本身的优劣；没有实际价值。</li>
<li><strong>事前分析：</strong>求出该算法的一个时间界限函数。<br>与此相关的因素有：<ul>
<li>依据算法选用何种策略；</li>
<li>问题的规模；</li>
<li>程序设计的语言；[<strong>注</strong>]：严书上是有这一条的，如果你的目标院校推荐书目不是这本，那么这一条可以省略。</li>
<li>编译程序所产生的机器代码的质量；</li>
<li>机器执行指令的速度；</li>
</ul>
</li>
</ul>
<h3 id="衡量算法的标准："><a href="#衡量算法的标准：" class="headerlink" title="衡量算法的标准："></a>衡量算法的标准：</h3><ul>
<li>1.时间复杂度，程序大概的执行次数，而非执行的时间。</li>
<li>2.空间复杂度，算法执行过程中大概所占的最大内存。</li>
<li>3.难易程度，即是否容易被人理解。</li>
<li>4.健壮性，即是否容易崩溃  </li>
</ul>
<p>复杂度：    O(1)&lt;O(㏒n)&lt;O(n)&lt;O(n㏒n)&lt;O(n²)&lt;O(n³)&lt;O(2ⁿ)&lt;O(n!)&lt;O(nⁿ)</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>02_浅析数据结构-图论之Floyd算法</title>
    <url>/2019/11/30/02-%E6%B5%85%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE%E8%AE%BA%E4%B9%8BFloyd%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="浅析数据结构-图论之Floyd算法"><a href="#浅析数据结构-图论之Floyd算法" class="headerlink" title="浅析数据结构-图论之Floyd算法"></a>浅析数据结构-图论之Floyd算法</h1><a id="more"></a>
<p>定义：</p>
<p>Floyd算法又称为插点法，是一种利用动态规划的思想寻找给定的加权图中多源点之间最短路径的算法，与Dijkstra算法类似。(定义摘自百度)</p>
<p>简单来说，这个算法来解决的<strong>任意两点之间的最短路径</strong>，它可以正确地处理向图的最短路径问题或有向图或者负权重（<u>但是可以不存在负权重循环</u>）。</p>
<p>由于该算法设计到动态规划的一些思想，所以笔者在思考某个问题的时候，并没有联想到到这个算法的本质，当然这是后话了。</p>
<hr>
<h3 id="分析问题"><a href="#分析问题" class="headerlink" title="分析问题"></a>分析问题</h3><p>闲话少叙，开始正题。</p>
<p>给出以下一个有向图(图片来自网络，太难画了)。<br><img src="https://myresou.oss-cn-shanghai.aliyuncs.com/DataStruct/img/arithmetic/Floyd%E7%AE%97%E6%B3%95/%E6%9C%89%E5%90%91%E5%9B%BE%E5%9B%BE%E7%A4%BA.png" alt="Floyd算法图例1" style="zoom:50%;"><br>这时候我们来思考一个问题：在这个有向图中，我想从 <strong>1</strong> 点到达到 <strong>3</strong> 点，有几种方式，几种方式到路程怎么样？</p>
<ol>
<li>从 <strong>1</strong> 可以直接到达 <strong>3</strong> 点，距离为6；</li>
<li>从 <strong>1</strong> 路过 <strong>2</strong> 号点，最后到达 <strong>3</strong> 点，距离是5；</li>
<li>从 <strong>1</strong> 路过 <strong>4</strong> 号点，最后到达 <strong>3</strong> 点，距离是16；</li>
<li>其他有关于多走几次回路的方式，就不再赘述。</li>
</ol>
<hr>
<p> 经过上面的分析，我们发现从 <strong>1</strong> 号点到达 <strong>3</strong> 号点，以经过 <strong>2</strong> 号点的方式距离最短。这时候我们来回顾摘自百度的有关Floyd算法的定义：<strong><em>Floyd算法又称为插点法</em></strong>，这个 <strong>2</strong> 号点就是定义所说点有关<strong>插点</strong>的解释了。也就是说，我们在路过其他点到达目的地的时候，往往会有奇效。</p>
<p> 这时候问题来了，从 <strong>1</strong> 号点到达 <strong>3</strong> 号点我们可以通过观察，轻易的写出老，那么所有的点到所有到点呢？这个案例扩充到N个点呢？很明显。仅通过肉眼观察是很难做到的。这时候必须通过计算机来解决此问题。</p>
<h3 id="我们继续分析这个问题，通过特例完成通解。"><a href="#我们继续分析这个问题，通过特例完成通解。" class="headerlink" title="我们继续分析这个问题，通过特例完成通解。"></a>我们继续分析这个问题，通过特例完成通解。</h3><p> 我们来想一想，如果要让任意两点（例如从顶点a点到顶点b）之间的距离变短，只能引入第三个点（顶点k），并通过这个顶点k中转即a-&gt;k-&gt;b，才可能缩短原来从顶点a点到顶点b的距离。那么这个中转的顶点k是1~n中的哪个点呢？甚至有时候不只通过一个点，而是经过两个点或者更多点中转会更短，即a-&gt;k1-&gt;k2b-&gt;或者a-&gt;k1-&gt;k2…-&gt;k-&gt;i…-&gt;b。</p>
<p> 分析有向图，必不可少的工具，就是 <strong>邻接矩阵</strong> ，我们来画出上述有向图的邻接矩阵。<br> <img src="https://myresou.oss-cn-shanghai.aliyuncs.com/DataStruct/img/arithmetic/Floyd%E7%AE%97%E6%B3%95/%E6%9C%89%E5%90%91%E5%9B%BE%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5.png" alt="有向图的邻接矩阵" style="zoom:50%;"><br>有向图，任意点到任意点本身到距离是0，没有直接通路的情况下，把距离记作 <strong>∞</strong> 。</p>
<h2 id="逐渐深入问题"><a href="#逐渐深入问题" class="headerlink" title="逐渐深入问题"></a>逐渐深入问题</h2><p>假定，我们只能路过 <strong>1</strong> 号点来作为中转点，这时候我们来求一下，各个点到各个点的最短距离。也就是说，如果两点之间直接距离与经过 <strong>1</strong> 号点点距离做比价，找出最短点距离；如果没有直接通路，则能通过 <strong>1</strong> 点能连通，那便是此条路为最短路径。</p>
<p>那我们应该如何求呢？我们把 <strong>i</strong> 点到 <strong>j</strong> 的距离记作e[<strong>i</strong>] [<strong>j</strong>]。只需判断e[<strong>i</strong>] [<strong>1</strong>] + e[<strong>1</strong>] [<strong>j</strong>]是否比e[<strong>i</strong>] [<strong>j</strong>]要小即可。e[<strong>i</strong>] [<strong>1</strong>]+e[<strong>1</strong>] [<strong>j</strong>]表示的是从 <strong>i</strong> 号顶点先到 <strong>1</strong> 号顶点，再从 <strong>1</strong> 号顶点到 <strong>j</strong> 号顶点的路程之和。其中 <strong>i</strong> 是<strong>1</strong>–<strong>n</strong>循环，<strong>j</strong> 也是<strong>1</strong>–<strong>n</strong>循环，代码实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">		<span class="keyword">if</span> (e[i][j] &gt; e[i][<span class="number">1</span>] + e[<span class="number">1</span>][j])</span><br><span class="line">			e[i][j] = e[i][<span class="number">1</span>] + e[<span class="number">1</span>][j];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在只允许经过1号顶点的情况下，任意两点之间的最短路程更新为：<br><img src="
https://myresou.oss-cn-shanghai.aliyuncs.com/DataStruct/img/arithmetic/Floyd%E7%AE%97%E6%B3%95/%E5%8F%AA%E7%BB%8F%E8%BF%871%E7%82%B9%E7%9A%84%E7%9F%A9%E9%98%B5.png" alt="只经过1点后距离更新后" style="zoom:50%;"><br><strong>我们继续思考问题：</strong>如果规定，只允许经过 <strong>1</strong> 号点和 <strong>2</strong> 号点，这时候各个点相互之间点距离怎么样又是怎么样的呢！？代码如下图所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">		<span class="keyword">for</span> (k = <span class="number">1</span>; k &lt;= <span class="number">2</span>; k++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (e[i][j] &gt; e[i][k] + e[k][j])</span><br><span class="line">				e[i][j] = e[i][k] + e[k][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看一下计算的结果：</p>
<p><img src="
https://myresou.oss-cn-shanghai.aliyuncs.com/DataStruct/img/arithmetic/Floyd%E7%AE%97%E6%B3%95/%E7%BB%8F%E8%BF%871%E5%92%8C2%E7%82%B9%E7%9F%A9%E9%98%B5.png" alt="只经过1号点和2号点" style="zoom:50%;"><br>在相比只允许通过1号顶点进行中转的情况下，这里允许通过1和2号顶点进行中转，使得e[<strong>1</strong>] [<strong>3</strong>]和e[<strong>4</strong>] [<strong>3</strong>]的路程变得更短了。</p>
<hr>
<p>这时候不难发现，当要求只允许经过经过 <strong>1</strong> – <strong>n</strong> 的时候，我们的算法可以这样书写：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">		<span class="keyword">for</span> (k = <span class="number">1</span>; k &lt;= n; k++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (e[i][j] &gt; e[i][k] + e[k][j])</span><br><span class="line">				e[i][j] = e[i][k] + e[k][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而，这样并不能解决实际问题，如果 <strong>1</strong> 到 <strong>2</strong> 点经过两个点的时候比只经过一个点距离更小时，不就是不满足最短路径的需求了吗？<br>不着急，这时候<u>算法还是五步，三层for循环</u>，我们只需要这样做：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (k = <span class="number">1</span>; k &lt;= n; k++)&#123;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (e[i][j] &gt; e[i][k] + e[k][j])</span><br><span class="line">				e[i][j] = e[i][k] + e[k][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，算法的核心代码已经说完了，现在有一个小小的问题：请问无穷大在代码里怎么表示呢？应该会有人说，不就是 int MAX = 99999999;吗？其实int型的无穷大，我们可以经常这么表示 int MAX = 0x3f3f3f; 至于为什么，就留给读者自行思考了，笔者就不再赘述了。</p>
<p><strong>注意</strong> ：不是所有的有向图都是正权边的，Floyd不适合带有 <strong>负权回路</strong> 的有向图，这样是没有最短路径的。</p>
<hr>
<h2 id="再深入思考"><a href="#再深入思考" class="headerlink" title="再深入思考"></a>再深入思考</h2><p>下面再看一个题目：<br><img src="https://myresou.oss-cn-shanghai.aliyuncs.com/DataStruct/img/arithmetic/Floyd%E7%AE%97%E6%B3%95/%E9%A2%98%E7%9B%AE.jpeg" alt="题示"><br>这一题，便可套用Floyd算法，虽然不是直接求得题目得解，使用此算法算是一种曲线救国的解法。读者可以自己动手试试。</p>
<p><a href="https://blog.csdn.net/jwsl999/article/details/103319713" target="_blank" rel="noopener">想评论？想留言？博客没有安装评论插件，那欢迎在我的CSDN博客中留言</a></p>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>图论</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>图论</tag>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
