<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>浅析数据结构</title>
    <url>/2019/11/24/%E6%B5%85%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h2 id="浅析数据结构"><a href="#浅析数据结构" class="headerlink" title="浅析数据结构"></a>浅析数据结构</h2><p>虽然我是一个菜鸟，但还是想把学到的东西和大家一起分享，有错误以及不足还请指正。</p>
<p>数据结构的知识总结于严奶奶的经典书籍、天勤、王道…</p>
<p>还有一些大佬的理解和自己的理解。</p>
<p>希望和大家一起学习，一起进步！</p>
<a id="more"></a>

<hr>
<h3 id="数据结构和算法概述"><a href="#数据结构和算法概述" class="headerlink" title="数据结构和算法概述"></a>数据结构和算法概述</h3><h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h3><p>​    <strong>1.指针</strong></p>
<p>​    <strong>2.结构体</strong></p>
<p>​    <strong>3.动态内存分配和释放</strong></p>
<h3 id="模块一："><a href="#模块一：" class="headerlink" title="模块一："></a>模块一：</h3><p>​    <strong>1.线性结构</strong></p>
<p>​    <strong>2.连续存储[数组]</strong></p>
<p>​    <strong>3.离散存储[链表]</strong></p>
<ul>
<li><strong>a.单链表</strong>  </li>
<li><strong>b.循环单链表</strong></li>
<li><strong>c.双链表&amp;循环双链表</strong>  </li>
</ul>
<p><strong>4.线性结构的两种常见应用</strong></p>
<ul>
<li><strong>a.栈</strong></li>
<li><strong>b.队列</strong></li>
</ul>
<p>​    </p>
<h3 id="模块二：-串"><a href="#模块二：-串" class="headerlink" title="模块二： 串"></a>模块二： 串</h3><p>​     <strong>1、串的定义以及实现</strong></p>
<p>​     <strong>2、串的模式匹配算法</strong></p>
<h3 id="模块三：数组"><a href="#模块三：数组" class="headerlink" title="模块三：数组"></a>模块三：数组</h3><p>​    <strong>1、数据的定义以及实现</strong></p>
<p>​    <strong>2、矩阵的压缩矩阵</strong></p>
<h3 id="专题：递归"><a href="#专题：递归" class="headerlink" title="专题：递归"></a>专题：递归</h3><p>​    <strong>1、1 + 2 + 3 +…+ 100的和</strong></p>
<p>​    <strong>2、求阶乘</strong></p>
<p>​    <strong>3、汉诺塔</strong></p>
<h3 id="模块四：非线性结构"><a href="#模块四：非线性结构" class="headerlink" title="模块四：非线性结构"></a>模块四：非线性结构</h3><p>​    <strong>1、树</strong></p>
<p>​    <strong>2、图</strong></p>
<h3 id="模块五：查找和排序"><a href="#模块五：查找和排序" class="headerlink" title="模块五：查找和排序"></a>模块五：查找和排序</h3><ul>
<li><strong>查找：</strong></li>
</ul>
<p>​        <strong>1. 静态查找表</strong></p>
<p>​        <strong>2、动态查找表</strong></p>
<p>​        <strong>2、 哈希表</strong></p>
<ul>
<li><strong>排序：</strong></li>
</ul>
<p>​        <strong>1、内部排序</strong></p>
<p>​        <strong>2、外部排序</strong> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"About Beautiful Thing"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>01_浅析数据之绪论</title>
    <url>/2019/11/29/01-%E6%B5%85%E6%9E%90%E6%95%B0%E6%8D%AE%E4%B9%8B%E7%BB%AA%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="浅析数据结构之绪论"><a href="#浅析数据结构之绪论" class="headerlink" title="浅析数据结构之绪论"></a>浅析数据结构之绪论</h1><a id="more"></a>

<h2 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a><strong>数据结构和算法</strong></h2><ul>
<li><strong>数据：</strong> 是客观事物的符号表示。在计算机科学中指的是所有能输入到计算机中并被计算机程序处理的符号的总称。</li>
<li><strong>数据元素：</strong>组成数据的，有一定意义的基本单位，在计算机中通常作为整体进行考虑和处理，也被称为记录。</li>
<li><strong>数据元素组成数据。</strong></li>
<li><strong>数据项：</strong>数据项是数据不可分割的最小单元，一个数据元素可以由若干个数据项组成。数据项是对客观事物某一方面特性的数据描述。</li>
<li><strong>数据对象：</strong>性质相同的数据元素的集合，是数据的子集</li>
</ul>
<hr>
<h2 id="数据结构概述"><a href="#数据结构概述" class="headerlink" title="数据结构概述"></a><strong>数据结构概述</strong></h2><p><strong>数据结构(Data Structure)：</strong>是指相互之间具有(存在)一定联系(关系)的数据元素的集合。元素之间的相互联系(关系)称为逻辑结构。数据元素之间的逻辑结构有<u>四种基本逻辑类型</u>：<br><strong>逻辑结构：</strong></p>
<ul>
<li><strong>1、集合结构：</strong><br>1.集合结构中数据元素同属于一个集合。<br>2.数据元素相互之间没有关系。</li>
<li><strong>2、线性结构：</strong> 数据元素之间是一对一的关系。</li>
<li><strong>3、树形结构：</strong> 数据元素之间一种一对多的层次关系。</li>
<li><strong>4、图状结构（网状结构）：</strong> 数据元素之间是多对多的关系。</li>
</ul>
<p><strong>物理结构：</strong>又叫存储结构，是指数据的逻辑结构在计算机中的存储形式。</p>
<ul>
<li><strong>1、线性：</strong>索引存储，数据元素的存储<br>数组、链表<br>具体应用：栈和队列（特殊的线性结构）</li>
<li><strong>2、非线性：</strong>散列存储，元素之间的关系的表示<br>  树、图</li>
</ul>
<p>元素之间的关系在计算机中有两种不同的表示方法：顺序表示和非顺序表示。由此得出两种不同的存储结构：<u>顺序存储结构</u>和<u>链式存储结构</u>。</p>
<ul>
<li><p><strong>顺序存储结构：</strong>用数据元素在存储器中的相对位置来表示数据元素之间的逻辑结构(关系)。</p>
</li>
<li><p><strong>链式存储结构：</strong>在每一个数据元素中增加一个存放另一个元素地址的指针(pointer )，用该指针来表示数据元素之间的逻辑结构(关系)。</p>
<p>数据的逻辑结构和物理结构是密不可分的两个方面，一个<em>算法的设计取决于所选定的逻辑结构</em>，而<em>算法的实现依赖于所采用的存储结构</em>。</p>
</li>
</ul>
<p>在C语言中，用一维数组表示顺序存储结构；用结构体类型表示链式存储结构</p>
<h3 id="数据结构的三个组成部分："><a href="#数据结构的三个组成部分：" class="headerlink" title="数据结构的三个组成部分："></a>数据结构的三个组成部分：</h3><ul>
<li><strong>逻辑结构：</strong> 数据元素之间逻辑关系的描述<br>D_S=（D，S）</li>
<li><strong>存储结构：</strong> 数据元素在计算机中的存储及其逻辑关系的表现称为数据的存储结构或物理结构。</li>
<li><strong>数据操作：</strong> 对数据要进行的运算。</li>
</ul>
<hr>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a><strong>算法</strong></h2><h3 id="算法的五大特性："><a href="#算法的五大特性：" class="headerlink" title="算法的五大特性："></a>算法的五大特性：</h3><ul>
<li>有穷性：有穷步 有穷时间</li>
<li>确定性：每一条指令都有明确的含义</li>
<li>可行性：算法描述的操作都是可以通过已经实现的基本运算执行有限次来实现</li>
<li>输入: 一个算法有零个或多个输入，这些输入取自于某个特定的对象集合</li>
<li>输出: 一个算法有一个或多个输出，这些输出是同输入有着某些特定关系的量</li>
</ul>
<h3 id="算法的设计要求"><a href="#算法的设计要求" class="headerlink" title="算法的设计要求"></a>算法的设计要求</h3><ul>
<li>正确性：算法应当满足具体问题的需求</li>
<li>可读性：算法主要是为了人的阅读与交流，其次才是机器执行</li>
<li>健壮性：输入的数据非法时，算法应当作出反应或者进行</li>
<li>通用性： 算法应具有一般性 ，即算法的处理结果对于一般的数据集合都成立。相应的处理，而不是产生莫名其妙的输出结果</li>
<li>高效率与低存储量需求： 效率指的是算法执行的时间；存储量需求指算法执行过程中所需要的最大存储空间。一般地，这两者与问题的规模有关</li>
</ul>
<h3 id="算法效率的质量"><a href="#算法效率的质量" class="headerlink" title="算法效率的质量"></a>算法效率的质量</h3><p>  算法执行时间需通过依据该算法编制的程序在计算机上运行所消耗的时间来度量。其方法通常有两种：</p>
<ul>
<li><strong>事后统计：</strong>计算机内部进行执行时间和实际占用空间的统计。<br>问题：必须先运行依据算法编制的程序；依赖软硬件环境，容易掩盖算法本身的优劣；没有实际价值。</li>
<li><strong>事前分析：</strong>求出该算法的一个时间界限函数。<br>与此相关的因素有：<ul>
<li>依据算法选用何种策略；</li>
<li>问题的规模；</li>
<li>程序设计的语言；[<strong>注</strong>]：严书上是有这一条的，如果你的目标院校推荐书目不是这本，那么这一条可以省略。</li>
<li>编译程序所产生的机器代码的质量；</li>
<li>机器执行指令的速度；</li>
</ul>
</li>
</ul>
<h3 id="衡量算法的标准："><a href="#衡量算法的标准：" class="headerlink" title="衡量算法的标准："></a>衡量算法的标准：</h3><ul>
<li>1.时间复杂度，程序大概的执行次数，而非执行的时间。</li>
<li>2.空间复杂度，算法执行过程中大概所占的最大内存。</li>
<li>3.难易程度，即是否容易被人理解。</li>
<li>4.健壮性，即是否容易崩溃  </li>
</ul>
<p>复杂度：    O(1)&lt;O(㏒n)&lt;O(n)&lt;O(n㏒n)&lt;O(n²)&lt;O(n³)&lt;O(2ⁿ)&lt;O(n!)&lt;O(nⁿ)</p>
<hr>
<h3 id="数据结构的地位"><a href="#数据结构的地位" class="headerlink" title="数据结构的地位"></a>数据结构的地位</h3><p>数据结构上软件中最核心的课程</p>
<h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><p>1.狭义的算法与数据的存储密切相关<br>2.广义的算法与数据的存储无关，广义的算法就是泛型<br><strong>泛型：</strong>利用某种方式达到的效果，不同的存数方式，执行的操作是一样的。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>02_浅析数据结构-图论之Floyd算法</title>
    <url>/2019/11/30/02-%E6%B5%85%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE%E8%AE%BA%E4%B9%8BFloyd%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="浅析数据结构-图论之Floyd算法"><a href="#浅析数据结构-图论之Floyd算法" class="headerlink" title="浅析数据结构-图论之Floyd算法"></a>浅析数据结构-图论之Floyd算法</h1><a id="more"></a>
<p>定义：</p>
<p>Floyd算法又称为插点法，是一种利用动态规划的思想寻找给定的加权图中多源点之间最短路径的算法，与Dijkstra算法类似。(定义摘自百度)</p>
<p>简单来说，这个算法来解决的<strong>任意两点之间的最短路径</strong>，它可以正确地处理向图的最短路径问题或有向图或者负权重（<u>但是可以不存在负权重循环</u>）。</p>
<p>由于该算法设计到动态规划的一些思想，所以笔者在思考某个问题的时候，并没有联想到到这个算法的本质，当然这是后话了。</p>
<hr>
<h3 id="分析问题"><a href="#分析问题" class="headerlink" title="分析问题"></a>分析问题</h3><p>闲话少叙，开始正题。</p>
<p>给出以下一个有向图(图片来自网络，太难画了)。<br><img src="https://myresou.oss-cn-shanghai.aliyuncs.com/DataStruct/img/arithmetic/Floyd%E7%AE%97%E6%B3%95/%E6%9C%89%E5%90%91%E5%9B%BE%E5%9B%BE%E7%A4%BA.png" alt="Floyd算法图例1" style="zoom:50%;"><br>这时候我们来思考一个问题：在这个有向图中，我想从 <strong>1</strong> 点到达到 <strong>3</strong> 点，有几种方式，几种方式到路程怎么样？</p>
<ol>
<li>从 <strong>1</strong> 可以直接到达 <strong>3</strong> 点，距离为6；</li>
<li>从 <strong>1</strong> 路过 <strong>2</strong> 号点，最后到达 <strong>3</strong> 点，距离是5；</li>
<li>从 <strong>1</strong> 路过 <strong>4</strong> 号点，最后到达 <strong>3</strong> 点，距离是16；</li>
<li>其他有关于多走几次回路的方式，就不再赘述。</li>
</ol>
<hr>
<p> 经过上面的分析，我们发现从 <strong>1</strong> 号点到达 <strong>3</strong> 号点，以经过 <strong>2</strong> 号点的方式距离最短。这时候我们来回顾摘自百度的有关Floyd算法的定义：<strong><em>Floyd算法又称为插点法</em></strong>，这个 <strong>2</strong> 号点就是定义所说点有关<strong>插点</strong>的解释了。也就是说，我们在路过其他点到达目的地的时候，往往会有奇效。</p>
<p> 这时候问题来了，从 <strong>1</strong> 号点到达 <strong>3</strong> 号点我们可以通过观察，轻易的写出老，那么所有的点到所有到点呢？这个案例扩充到N个点呢？很明显。仅通过肉眼观察是很难做到的。这时候必须通过计算机来解决此问题。</p>
<h3 id="我们继续分析这个问题，通过特例完成通解。"><a href="#我们继续分析这个问题，通过特例完成通解。" class="headerlink" title="我们继续分析这个问题，通过特例完成通解。"></a>我们继续分析这个问题，通过特例完成通解。</h3><p> 我们来想一想，如果要让任意两点（例如从顶点a点到顶点b）之间的距离变短，只能引入第三个点（顶点k），并通过这个顶点k中转即a-&gt;k-&gt;b，才可能缩短原来从顶点a点到顶点b的距离。那么这个中转的顶点k是1~n中的哪个点呢？甚至有时候不只通过一个点，而是经过两个点或者更多点中转会更短，即a-&gt;k1-&gt;k2b-&gt;或者a-&gt;k1-&gt;k2…-&gt;k-&gt;i…-&gt;b。</p>
<p> 分析有向图，必不可少的工具，就是 <strong>邻接矩阵</strong> ，我们来画出上述有向图的邻接矩阵。<br> <img src="https://myresou.oss-cn-shanghai.aliyuncs.com/DataStruct/img/arithmetic/Floyd%E7%AE%97%E6%B3%95/%E6%9C%89%E5%90%91%E5%9B%BE%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5.png" alt="有向图的邻接矩阵" style="zoom:50%;"><br>有向图，任意点到任意点本身到距离是0，没有直接通路的情况下，把距离记作 <strong>∞</strong> 。</p>
<h2 id="逐渐深入问题"><a href="#逐渐深入问题" class="headerlink" title="逐渐深入问题"></a>逐渐深入问题</h2><p>假定，我们只能路过 <strong>1</strong> 号点来作为中转点，这时候我们来求一下，各个点到各个点的最短距离。也就是说，如果两点之间直接距离与经过 <strong>1</strong> 号点点距离做比价，找出最短点距离；如果没有直接通路，则能通过 <strong>1</strong> 点能连通，那便是此条路为最短路径。</p>
<p>那我们应该如何求呢？我们把 <strong>i</strong> 点到 <strong>j</strong> 的距离记作e[<strong>i</strong>] [<strong>j</strong>]。只需判断e[<strong>i</strong>] [<strong>1</strong>] + e[<strong>1</strong>] [<strong>j</strong>]是否比e[<strong>i</strong>] [<strong>j</strong>]要小即可。e[<strong>i</strong>] [<strong>1</strong>]+e[<strong>1</strong>] [<strong>j</strong>]表示的是从 <strong>i</strong> 号顶点先到 <strong>1</strong> 号顶点，再从 <strong>1</strong> 号顶点到 <strong>j</strong> 号顶点的路程之和。其中 <strong>i</strong> 是<strong>1</strong>–<strong>n</strong>循环，<strong>j</strong> 也是<strong>1</strong>–<strong>n</strong>循环，代码实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">		<span class="keyword">if</span> (e[i][j] &gt; e[i][<span class="number">1</span>] + e[<span class="number">1</span>][j])</span><br><span class="line">			e[i][j] = e[i][<span class="number">1</span>] + e[<span class="number">1</span>][j];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在只允许经过1号顶点的情况下，任意两点之间的最短路程更新为：<br><img src="
https://myresou.oss-cn-shanghai.aliyuncs.com/DataStruct/img/arithmetic/Floyd%E7%AE%97%E6%B3%95/%E5%8F%AA%E7%BB%8F%E8%BF%871%E7%82%B9%E7%9A%84%E7%9F%A9%E9%98%B5.png" alt="只经过1点后距离更新后" style="zoom:50%;"><br><strong>我们继续思考问题：</strong>如果规定，只允许经过 <strong>1</strong> 号点和 <strong>2</strong> 号点，这时候各个点相互之间点距离怎么样又是怎么样的呢！？代码如下图所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">		<span class="keyword">for</span> (k = <span class="number">1</span>; k &lt;= <span class="number">2</span>; k++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (e[i][j] &gt; e[i][k] + e[k][j])</span><br><span class="line">				e[i][j] = e[i][k] + e[k][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看一下计算的结果：</p>
<p><img src="
https://myresou.oss-cn-shanghai.aliyuncs.com/DataStruct/img/arithmetic/Floyd%E7%AE%97%E6%B3%95/%E7%BB%8F%E8%BF%871%E5%92%8C2%E7%82%B9%E7%9F%A9%E9%98%B5.png" alt="只经过1号点和2号点" style="zoom:50%;"><br>在相比只允许通过1号顶点进行中转的情况下，这里允许通过1和2号顶点进行中转，使得e[<strong>1</strong>] [<strong>3</strong>]和e[<strong>4</strong>] [<strong>3</strong>]的路程变得更短了。</p>
<hr>
<p>这时候不难发现，当要求只允许经过经过 <strong>1</strong> – <strong>n</strong> 的时候，我们的算法可以这样书写：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">		<span class="keyword">for</span> (k = <span class="number">1</span>; k &lt;= n; k++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (e[i][j] &gt; e[i][k] + e[k][j])</span><br><span class="line">				e[i][j] = e[i][k] + e[k][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而，这样并不能解决实际问题，如果 <strong>1</strong> 到 <strong>2</strong> 点经过两个点的时候比只经过一个点距离更小时，不就是不满足最短路径的需求了吗？<br>不着急，这时候<u>算法还是五步，三层for循环</u>，我们只需要这样做：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (k = <span class="number">1</span>; k &lt;= n; k++)&#123;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (e[i][j] &gt; e[i][k] + e[k][j])</span><br><span class="line">				e[i][j] = e[i][k] + e[k][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，算法的核心代码已经说完了，现在有一个小小的问题：请问无穷大在代码里怎么表示呢？应该会有人说，不就是 int MAX = 99999999;吗？其实int型的无穷大，我们可以经常这么表示 int MAX = 0x3f3f3f; 至于为什么，就留给读者自行思考了，笔者就不再赘述了。</p>
<p><strong>注意</strong> ：不是所有的有向图都是正权边的，Floyd不适合带有 <strong>负权回路</strong> 的有向图，这样是没有最短路径的。</p>
<hr>
<h2 id="再深入思考"><a href="#再深入思考" class="headerlink" title="再深入思考"></a>再深入思考</h2><p>下面再看一个题目：<br><img src="https://myresou.oss-cn-shanghai.aliyuncs.com/DataStruct/img/arithmetic/Floyd%E7%AE%97%E6%B3%95/%E9%A2%98%E7%9B%AE.jpeg" alt="题示"><br>这一题，便可套用Floyd算法，虽然不是直接求得题目得解，使用此算法算是一种曲线救国的解法。读者可以自己动手试试。</p>
<p><a href="https://blog.csdn.net/jwsl999/article/details/103319713" target="_blank" rel="noopener">想评论？想留言？博客没有安装评论插件，那欢迎在我的CSDN博客中留言</a></p>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>图论</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>图论</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>03-浅析数据结构之预备知识</title>
    <url>/2019/12/04/03-%E6%B5%85%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1 id="浅析数据结构之预备知识"><a href="#浅析数据结构之预备知识" class="headerlink" title="浅析数据结构之预备知识"></a>浅析数据结构之预备知识</h1><a id="more"></a>

<ul>
<li><h2 id="a-指针"><a href="#a-指针" class="headerlink" title="a.指针"></a><strong>a.指针</strong></h2></li>
</ul>
<p><strong>定义：</strong>地址<br> 内存单元的编号<br> 从0开始的非负整数（0—4G-1）即（0—FFFFFFFF）</p>
<img src="https://myresou.oss-cn-shanghai.aliyuncs.com/DataStruct/img/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/%E5%86%85%E5%AD%98.png" alt="image" style="zoom:50%;">

<p><strong>指针:</strong><br>1.指针是存放内存单元的变量<br>2.指针的本质操作受限的非负整数（不可加减）</p>
<ul>
<li><h2 id="b-结构体"><a href="#b-结构体" class="headerlink" title="b.结构体"></a><strong>b.结构体</strong></h2><strong>①什么叫结构体？</strong><br>结构体用户根据自己的实际需要自己定义的复合的数据类型。<br><strong>②如何使用结构体？</strong><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Struct Student &#123;</span><br><span class="line">	<span class="keyword">int</span> sid;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">200</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">st</span> = &#123;</span><span class="number">1000</span>,”何桑”，<span class="number">20</span>&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Student</span> *<span class="title">pst</span>;</span></span><br><span class="line">	pst = &amp;st;</span><br><span class="line">	pst-&gt;sid = <span class="number">99</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>pst所指向的结构体的成员sid。<br>通常遇到问类似 Struct Student st 结构体的大小，这涉及到对齐问题，笔者不多赘述。</p>
<p> <strong>③注意事项</strong><br> 1.结构体不能加减乘除，但可以相互赋值。<br> 2.普通结构体变量和结构体指针变量作为函数传参的问题。正常情况下使用指针作为参数的效率比较高，因为指针只占4个字节。</p>
<ul>
<li><h2 id="c-动态分配内存"><a href="#c-动态分配内存" class="headerlink" title="c.动态分配内存"></a><strong>c.动态分配内存</strong></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *pArr = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * nLen);</span><br><span class="line">pArr[<span class="number">1</span>] = <span class="number">10</span>; <span class="comment">//类似于 a[1] = 10;</span></span><br><span class="line"><span class="built_in">free</span>(pArr);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>注意：</strong>malloc动态分配内存需要手动释放(free),不然需要等到程序运行完毕才可以释放，所以同时可以使用malloc跨函数使用内存，因为不使用动态分配内存，函数运行完毕立即被释放。</p>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>预备知识</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>预备知识</tag>
      </tags>
  </entry>
  <entry>
    <title>04-浅析数据结构-线性结构之线性表</title>
    <url>/2019/12/07/04-%E6%B5%85%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E4%B9%8B%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="浅析数据结构-线性结构之线性表"><a href="#浅析数据结构-线性结构之线性表" class="headerlink" title="浅析数据结构-线性结构之线性表"></a>浅析数据结构-线性结构之线性表</h1><a id="more"></a>

<h3 id="线性结构的特点："><a href="#线性结构的特点：" class="headerlink" title="线性结构的特点："></a><strong>线性结构的特点：</strong></h3><ul>
<li>① 存在一个唯一的被称为“第一个”的数据元素；</li>
<li>② 存在一个唯一的被称为“最后一个”的数据元素；</li>
<li>③ 除第一个元素外，每个元素均有唯一一个直接前驱；</li>
<li>④ 除最后一个元素外，每个元素均有唯一一个直接后继。</li>
</ul>
<p><strong>线性表：</strong>是由n(n≧0)个数据元素(结点)a1，a2， …an组成的有限序列。该序列中的所有结点具有相同的数据类型。其中数据元素的个数n称为线性表的长度。<br>当n=0时，称为空表。<br>当n&gt;0时，将非空的线性表记作： (a1，a2，…an)<br>a1称为线性表的第一个(首)结点，an称为线性表的最后一个(尾)结点。<br>a1，a2，…ai-1都是ai(2≦i≦n)的前驱，其中ai-1是ai的直接前驱;<br>ai+1，ai+2，…an都是ai(1≦i ≦n-1)的后继，其中ai+1是ai的直接后继。</p>
<p><strong>注：</strong>一个数据元素可以由若干个<u>数据项</u>组成。在这情况下，常把数据元素称为<u>记录</u>，含有大量记录的线性表称为<u>文件</u>。</p>
<h2 id="线性表的表示与实现"><a href="#线性表的表示与实现" class="headerlink" title="线性表的表示与实现"></a>线性表的表示与实现</h2><ul>
<li><strong>a.顺序存储[数组]</strong></li>
</ul>
<p><strong>顺序存储 ：</strong>[<strong>数组</strong>]把线性表的结点按逻辑顺序依次存放在一组地址连续的存储单元里。用这种方法存储的线性表简称顺序表。</p>
<ul>
<li><strong>①什么是数组？</strong><br>元素类型相同，大小相等。</li>
<li><strong>②数组的优缺点：</strong><ul>
<li>优点：<br>1、按照索引查询元素速度快<br>2、能存储大量数据<br>3、按照索引遍历数组方便</li>
<li>缺点：<br>1、根据内容查找元素速度慢<br>2、数组的大小一经确定不能改变。<br>3、数组只能存储一种类型的数据<br>4、增加、删除元素效率慢<br>5、未封装任何方法，所有操作都需要用户自己定义。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1、CreatList(SqList &amp;L,int n) </span></span><br><span class="line"><span class="comment">参数：顺序表L，顺序表长度n 功能：创建长度为的顺序表 时间复杂度：O(n)</span></span><br><span class="line"><span class="comment">2、InitList(SqList &amp;L) </span></span><br><span class="line"><span class="comment">参数：顺序表L 功能：初始化 时间复杂度:O(1)</span></span><br><span class="line"><span class="comment">3、InsertList(SqList &amp;L,int i,ElemType e) </span></span><br><span class="line"><span class="comment">参数:顺序表L,位置i,元素e 功能：位置i处插入元素e 时间复杂度:O(n)</span></span><br><span class="line"><span class="comment">4、ListDelete(SqList &amp;L,int i) </span></span><br><span class="line"><span class="comment">参数:顺序表L,位置i 功能：删除位置i处元素 时间复杂度:O(n)</span></span><br><span class="line"><span class="comment">5、LocateElem(SqList L,ElemType e) </span></span><br><span class="line"><span class="comment">参数:顺序表L,元素e 功能：返回第一个等于e的元素的位置 时间复杂度:O(n)</span></span><br><span class="line"><span class="comment">6、PrintList(SqList L) </span></span><br><span class="line"><span class="comment">参数:顺序表L 功能：遍历L，并输出</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ElemType int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Status int</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//顺序表数据结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  ElemType data[MaxSize];<span class="comment">//顺序表元素</span></span><br><span class="line">  <span class="keyword">int</span> length;            <span class="comment">//顺序表当前长度</span></span><br><span class="line">&#125;SqList;</span><br><span class="line"><span class="comment">//************************基本操作函数****************************//</span></span><br><span class="line"><span class="comment">//初始化顺序表函数，构造一个空的顺序表 </span></span><br><span class="line"><span class="function">Status <span class="title">InitList</span><span class="params">(SqList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(L.data, <span class="number">0</span>, <span class="keyword">sizeof</span>(L));<span class="comment">//初始化数据为0</span></span><br><span class="line">  L.length = <span class="number">0</span>;                <span class="comment">//初始化长度为0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建顺序表函数 初始化前n个数据</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CreatList</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n&lt;<span class="number">0</span> || n&gt;MaxSize)<span class="literal">false</span>;<span class="comment">//n非法</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;L.data[i]);</span><br><span class="line">    L.length++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//插入函数 位置i插入数据 i及之后元素后移  1=&lt;i&lt;=length+1 </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InsertList</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> i, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;L.length + <span class="number">1</span>) <span class="comment">//判断位置是否有效</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"位置无效！！！\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (L.length &gt;= MaxSize)<span class="comment">//判断存储空间是否已满</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"当前存储空间已满！！！\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = L.length; j &gt;= i; j--)<span class="comment">//位置i及之后元素后移</span></span><br><span class="line">  &#123;</span><br><span class="line">    L.data[j] = L.data[j - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  L.data[i - <span class="number">1</span>] = e;</span><br><span class="line">  L.length++;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除函数 删除位置i的元素 i之后的元素依次前移</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span>  <span class="title">ListDelete</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;L.length)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"位置无效！！！\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= L.length - <span class="number">1</span>; j++)<span class="comment">//位置i之后元素依次前移覆盖</span></span><br><span class="line">  &#123;</span><br><span class="line">    L.data[j - <span class="number">1</span>] = L.data[j];</span><br><span class="line">  &#125;</span><br><span class="line">  L.length--;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找函数 按位置从小到大查找第一个值等于e的元素 并返回位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateElem</span><span class="params">(SqList L, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;L.length; i++)<span class="comment">//从低位置查找</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (L.data[i] == e)</span><br><span class="line">      <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//倒置函数 将原顺序表直接倒置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reverse</span><span class="params">(SqList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (L.length)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;L.length - <span class="number">1</span> - i; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> t = L.data[i];</span><br><span class="line">      L.data[i] = L.data[L.length - <span class="number">1</span> - i];</span><br><span class="line">      L.data[L.length - <span class="number">1</span> - i] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//***************************功能函数***********************************//</span></span><br><span class="line"><span class="comment">//输出功能函数 按位置从小到大输出顺序表所有元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintList</span><span class="params">(SqList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"当前顺序表所有元素:"</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;L.length; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, L.data[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建顺序表函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Create</span><span class="params">(SqList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n; <span class="keyword">bool</span> flag;</span><br><span class="line">  L.length = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"请输入要创建的顺序表长度(&gt;1):"</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"请输入%d个数（空格隔开）:"</span>, n);</span><br><span class="line">  flag = CreatList(L, n);</span><br><span class="line">  <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"创建成功！\n"</span>);</span><br><span class="line">    PrintList(L);</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"输入长度非法！\n"</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//插入功能函数 调用InsertList完成顺序表元素插入 </span></span><br><span class="line"><span class="comment">//调用PrintList函数显示插入成功后的结果</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(SqList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> place; ElemType e; <span class="keyword">bool</span> flag;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"请输入要插入的位置(从1开始)及元素:\n"</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;place, &amp;e);</span><br><span class="line">  flag = InsertList(L, place, e);</span><br><span class="line">  <span class="keyword">if</span> (flag)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"插入成功！！！\n"</span>);</span><br><span class="line">    PrintList(L);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除功能函数 调用ListDelete函数完成顺序表的删除 </span></span><br><span class="line"><span class="comment">//调用PrintList函数显示插入成功后的结果</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">(SqList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> place; <span class="keyword">bool</span> flag;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"请输入要删除的位置(从1开始):\n"</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;place);</span><br><span class="line">  flag = ListDelete(L, place);</span><br><span class="line">  <span class="keyword">if</span> (flag)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"删除成功！！！\n"</span>);</span><br><span class="line">    PrintList(L);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找功能函数 调用LocateElem查找元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Search</span><span class="params">(SqList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ElemType e; <span class="keyword">int</span> flag;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"请输入要查找的值:\n"</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;e);</span><br><span class="line">  flag = LocateElem(L, e);</span><br><span class="line">  <span class="keyword">if</span> (flag)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"该元素位置为:%d\n"</span>, flag);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"未找到该元素！\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//菜单</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">menu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"********1.创建    2.插入*********\n"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"********3.删除    4.查找*********\n"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"********5.倒置    6.输出*********\n"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"********7.退出    *****************"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  SqList L; <span class="keyword">int</span> choice;</span><br><span class="line">  InitList(L);</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    menu();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入菜单序号：\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;choice);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">7</span> == choice) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">switch</span> (choice)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:Create(L); <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:Insert(L); <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:Delete(L); <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>:Search(L); <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">5</span>:Reverse(L); <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">6</span>:PrintList(L); <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:<span class="built_in">printf</span>(<span class="string">"输入错误！！！\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>g++和CLion，运行界面：<img src="https://myresou.oss-cn-shanghai.aliyuncs.com/DataStruct/img/%E9%93%BE%E8%A1%A8/%E8%BF%90%E8%A1%8C%E7%95%8C%E9%9D%A2.png" alt="运行界面" style="zoom:50%;"></p>
<p>这种写法是所见的大多的写法，个人认为这种写法稍欠些想法，在结构体中为什么要直接放入一个数组呢？我们是不是可以这么写：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  ElemType *data;	<span class="comment">//顺序表元素</span></span><br><span class="line">  <span class="keyword">int</span> length;		<span class="comment">//顺序表当前长度</span></span><br><span class="line">  <span class="keyword">int</span> nLength;		<span class="comment">//顺序表的有效长度</span></span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure>

<p>然后在在生成顺序表的时候，给<strong>ElemType *data</strong>赋值空间，类似于这么写：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//nLength为用户手动输入的有效元素的个数</span></span><br><span class="line">ElemType* data = (ElemType*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ElemType) * nLength);</span><br></pre></td></tr></table></figure>

<p>当然，这种写法书上确实没写，笔者也不确定这种写法的正确性，只是这么一说，感兴趣的读者可以试着思考一下。不再赘述。</p>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>线性结构</category>
        <category>线性表</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>线性结构</tag>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title>05-浅析数据结构-线性结构之线性表_链表</title>
    <url>/2019/12/07/05-%E6%B5%85%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E4%B9%8B%E7%BA%BF%E6%80%A7%E8%A1%A8-%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="浅析数据结构-线性结构之线性表-链表"><a href="#浅析数据结构-线性结构之线性表-链表" class="headerlink" title="浅析数据结构-线性结构之线性表-链表"></a>浅析数据结构-线性结构之线性表-链表</h1><a id="more"></a>

<h2 id="b-链式存储-链表"><a href="#b-链式存储-链表" class="headerlink" title="b.链式存储[链表]"></a><strong>b.链式存储[链表]</strong></h2><p><strong>重要性：</strong>学习树和图的基础<br><strong>定义：</strong></p>
<ul>
<li>1.N个结点离散分配，彼此通过指针相连；</li>
<li>2.每个结点只有一个前驱结点，每个结点只有一个后续结点；</li>
<li>3.首结点没有前驱结点，尾结点没有后续结点。</li>
</ul>
<p><strong>链表的优缺点：</strong></p>
<ul>
<li>优点:<br>1:： 删除 不需移动其他元素, 只需改变指针.<br>2：结点在内存中空间不要求连续!空间利用率高<br>3：内存利用率高</li>
<li>缺点:<br>1：数组元素效率低,例如:访问第100个元素,必须从头节一直next99次才能找到。</li>
</ul>
<p><strong>专业术语：</strong></p>
<p><img src="https://myresou.oss-cn-shanghai.aliyuncs.com/DataStruct/img/%E9%93%BE%E8%A1%A8/%E4%B8%93%E4%B8%9A%E6%9C%AF%E8%AF%AD.png" alt="专业术语"></p>
<p><strong>首结点：</strong>第一个有效结点<br><strong>尾结点：</strong>最后一个有效结点<br><strong>头结点：</strong></p>
<ul>
<li>头结点数据类型和首结点类型一样</li>
<li>第一个有效结点之前的结点</li>
<li>头结点并不存放数据</li>
</ul>
<p><strong>头指针：</strong>指向头结点的指针变量<br><strong>尾指针：</strong>指向尾结点的指针变量</p>
<h3 id="为什么需要使用头结点？"><a href="#为什么需要使用头结点？" class="headerlink" title="为什么需要使用头结点？"></a>为什么需要使用头结点？</h3><p>对链表进行操作的时候，在首结点加入一个没有实际含义的头结点，方便操作。</p>
<h3 id="如果希望通过一个函数对链表进行处理，我们至少需要哪些参数？"><a href="#如果希望通过一个函数对链表进行处理，我们至少需要哪些参数？" class="headerlink" title="如果希望通过一个函数对链表进行处理，我们至少需要哪些参数？"></a>如果希望通过一个函数对链表进行处理，我们至少需要哪些参数？</h3><ul>
<li>确定链表需要一个参数：头指针</li>
<li>因为我们通过头指针就可以推算出链表的其他所有参数。</li>
</ul>
<h3 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h3><ul>
<li><p>单链表：每一个结点上面有两个指针域</p>
</li>
<li><p>双链表：每一个结点上面有两个指针域</p>
</li>
<li><p>循环链表：能通过任何一个结点找到其他结点</p>
</li>
<li><p>非循环链表</p>
</li>
</ul>
<h3 id="插入结点："><a href="#插入结点：" class="headerlink" title="插入结点："></a>插入结点：</h3><p><img src="https://myresou.oss-cn-shanghai.aliyuncs.com/DataStruct/img/%E9%93%BE%E8%A1%A8/%E6%8F%92%E5%85%A5%E7%BB%93%E7%82%B9.png" alt="插入结点"></p>
<p><strong>a.</strong> r = p-&gt;pNext;p-&gt;pNext = q;q-&gt;qNext = r;<br><strong>b.</strong> q-&gt;pNext = p-&gt;pNext;p-&gt;pNext = q;</p>
<h3 id="删除结点："><a href="#删除结点：" class="headerlink" title="删除结点："></a>删除结点：</h3><p><img src="https://myresou.oss-cn-shanghai.aliyuncs.com/DataStruct/img/%E9%93%BE%E8%A1%A8/%E5%88%A0%E9%99%A4%E7%BB%93%E7%82%B9.png" alt="删除结点"></p>
<p>直接写：p-&gt;pNext = p-&gt;pNext-&gt;pNext;是错误的，会造成内存泄漏。<br>r = p-&gt;pNext;p-&gt;pNext = p-&gt;pNext-&gt;pNext;free(r);</p>
<h3 id="链表的头插法："><a href="#链表的头插法：" class="headerlink" title="链表的头插法："></a>链表的头插法：</h3><p>链表的头插法简单来说，就是每一个新结点都插入在最前端，即头结点之后。<br><img src="https://myresou.oss-cn-shanghai.aliyuncs.com/DataStruct/img/%E9%93%BE%E8%A1%A8/%E9%93%BE%E8%A1%A8%E5%A4%B4%E6%8F%92%E6%B3%95.png" alt="链表头插法"></p>
<h3 id="链表的尾插法："><a href="#链表的尾插法：" class="headerlink" title="链表的尾插法："></a>链表的尾插法：</h3><p>链表的尾插法，新结点每次都插入在最后一个。<br><img src="https://myresou.oss-cn-shanghai.aliyuncs.com/DataStruct/img/%E9%93%BE%E8%A1%A8/%E9%93%BE%E8%A1%A8%E5%B0%BE%E6%8F%92%E6%B3%95.png" alt="链表尾插法"></p>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>线性结构</category>
        <category>线性表</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>线性结构</tag>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title>#LeetCode_01_26删除排序数组中的重复项</title>
    <url>/2019/12/11/LeetCode-01-26%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
    <content><![CDATA[<h1 id="LeetCode-26删除排序数组中的重复项"><a href="#LeetCode-26删除排序数组中的重复项" class="headerlink" title="LeetCode_26删除排序数组中的重复项"></a>LeetCode_26删除排序数组中的重复项</h1><a id="more"></a>

<p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p>
<p><strong>示例 1:</strong><br>给定数组 nums = [1,1,2],<br>函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。<br>你不需要考虑数组中超出新长度后面的元素。</p>
<p><strong>示例 2:</strong><br>给定 nums = [0,0,1,1,1,2,2,3,3,4],<br>函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。<br>你不需要考虑数组中超出新长度后面的元素。</p>
<p><strong>说明:</strong><br>为什么返回数值是整数，但输出的答案是数组呢?<br><strong><em>请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</em></strong></p>
<p>你可以想象内部操作如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span><br><span class="line">int len = removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line">// 在函数里修改输入数组对于调用者是可见的。</span><br><span class="line">// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。</span><br><span class="line">for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>这道题是一道简单题，先读明白题目，理清题意。</p>
<p>由于数组是已经排序好的，那么重复的元素比相邻。<br>删除重复的元素，就是把下一个不重复的元素，覆盖到重复元素的后面，这也就是题目 <strong><em>你不需要考虑数组中超出新长度后面的元素。</em></strong>  简言之，只要返回有效的计数个数就行。</p>
<p>这题采用双指针算法，慢指针指向需要填充的位置，快指针快速遍历数组。<strong>注意</strong>，最后只需要快指针遍历到数组最后一个元素，并判断完就可以。</p>
<h3 id="图示以及代码："><a href="#图示以及代码：" class="headerlink" title="图示以及代码："></a>图示以及代码：</h3><img src="https://myresou.oss-cn-shanghai.aliyuncs.com/LeetCode/26%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/%E6%88%AA%E5%B1%8F2019-12-1123.10.22.png" alt="图解" style="zoom:50%;">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//数组长度</span></span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        数组只有一个元素，则符合题目要求，直接返回。</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//慢指针从0开始</span></span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//快指针从1开始</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> fast = <span class="number">1</span>;fast &lt; len;++fast) &#123;</span><br><span class="line">            <span class="comment">//如果遇到下一个不重复的</span></span><br><span class="line">            <span class="keyword">if</span>(nums[fast] != nums[slow]) &#123;</span><br><span class="line">                <span class="comment">//则直接放在慢指针后面的元素，慢指针后移</span></span><br><span class="line">                nums[++slow] = nums[fast];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//慢指针加1，就是新数组符合的元素的个数</span></span><br><span class="line">        <span class="keyword">return</span> slow + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
        <category>双指针</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
</search>
